---
title: HTML 5 Client Validation
date: "2020-12-21"
toc: true
---

# HTML 5 Client Validation

<br />

<Summary>

**Prefix:** I wanted to create a simple HTML form that is intended to function without requiring JavaScript, and without me
having any control over server side validation. That's not to say there is no server side validation, just that I have
no control over how eager it is to throw away invalid data. With that said, I hoped to catch as many issues as possible
before sending the data over to maximize the chance of success. Again, ideally without JavaScript.

The remainders of this post summarize my experience with HTML's Client Validation.

</Summary>

<Fragment>
    { props.toc }
</Fragment>

---

## Errors by Default
Fields with client validation requirements, such as `required`, that do not also provide default values that pass
validation are automatically in an `:invalid` state before any user interaction has taken place. This basically means 
that you should avoid applying styles to the `:invalid` pseudo-selector for the purpose of making errors identifyable. 
Otherwise, on first load the form will be largely indistinguishalbe from a typical screenshot of Doom Eternal. Or, in
other words, we can't use `:invalid` to style invalid fields -- off to a great start already.

So then wait, how should you go about marking validation errors on the form if you can't use `:invalid`? Good question,
you should probably create your own `.invalid` class and apply it after the user at least interacted with the field.
You'll need to use JavaScript to do this. What about users without JavaScript, I thought one of the big reasons for
using HTML5 Client Validation was to not depend on JS? Well, your choices are as follows:

1.  Style `:invalid` to suggest the field is invalid
    -   Your form will likely look like it was the scene of a violent crime.
    -   It will inevitably appear that your site is buggy because it can't even load a fresh page without having errors
        all over it.
    -   The user may be discouraged from working through all the problems that they didn't cause.

2. Restrict invalid styles to `:invalid:focus`
    -   This hides the errors until the user focuses the field, preventing an overabundance of errors from being shown
        at any one point in time.
    -   However, it is still apparent to the user that each field they click on will start from an error state.
    -   Once the form has been filled out the user will not be able to identify any new or remaining errors on the form 
        unless they focus through each field manually or try to submit the form.
    -   The user will likely have to make multiple attempts at submitting the form since since each submition will only
        identify one validation failure at a time.

3. Don't show any errors yourself and let the browser point them out as needed.
    -   You will have basically no styling control and will be at the mercy of the browser to communicate problems to
        the user. In the case of Firefox a red glow will show up around invalid fields, but only if you haven't changed 
        the `border-shadow` property on any of your form fields. You can also modify this effect using the
        `:-moz-ui-invalid` pseudo-selector, but doing so is discouraged by MDN since the property is not standard. The
        holy grail successor, `:user-invalid` (what `:invalid` should have always been), is probably still years away.
    -   Again, you are at the mercy of the browser, so how good or bad the user experience is may vary drastically. It
        may be what you would have wanted to design yourself, or it may be equivalent to option 2 above.

So option 3, aka *do-absolutely-nothing-at-all*, is the most reasonable choice in my opinion. Plus it has the advantage 
of providing you with a clean starting point for when you inevitably do end up using JavaScript to do things correctly.

---

## Required (but-not-really)

Name me one time you wanted to make some piece of data required and also chose to accept an empty or blank string as a
valid value for that data. Now, I'm sure a situation like that *can* exist, but I am also sure it is not the common 
case; we're not typically designing forms for submitting 
[whitespace](https://en.wikipedia.org/wiki/Whitespace_%28programming_language%29) code. So why is it that this is the 
default behavior of so many `required` flags in this day and age? What practical purpose does this flag even serve? 

Congratulations, you've erradicated the `null` check of the following code:
```JavaScript
if (value === null || typeof value !== 'string' || value.trim() === '' || ...) {
    return "This field is required, and I really mean it this time";
}
```
It's just a shame that I still need the rest of it, maybe in the next decade's big spec update, eh?

I realize many will find this extremely pedantic and will want to tell me to just use pattern validation to isolate
blank strings if I don't want to accept them. But you can't, at least not for `<textarea>` elements, these cannot be
validated with regular expressions, nor is there any reasonable way to do so without yet again needing JavaScript to do 
it. This could have easily been avoided by having the `required` atrribute actually give you practical behavior.

---

## Ambiguous by Design

Lets start by highlighting some documentation from MDN about validating fields using regular expressions:

> When a control has a `pattern` attribute, the `title` attribute, if used, must describe the pattern.

This would be due to the fact that any validation errors resulting from failed pattern matches will display a message
containing the value of the `title` attribute in an effort to guide the user to the source of the error. This message is
shown by the browser and is where users will immediately shift their attention to as it is the immediate feedback to 
their unsuccessful action. Ok so far, so lets go on:

> While `title`s are used by some browsers to populate error messaging, because browsers sometimes also show the title 
> as text on hover, it therefore shows in non-error situations, so be careful not to word titles as if an error has 
> occurred.

Being asked to provide guidance on resolving validation errors while also having to word it for situations where no
error has actually occurred is ridiculous. Why is the main source of input for providing relevant information on fixing
input errors the same piece of text that pops up if you hover over the field?

In essence, if you'd like to show a detailed and specific error message when an error occurs, it will now also show up 
completely out of context when somewhere else. Yes you can show your error information somewhere else on the page, but
that's not where the users will be looking. The immediate reaction to being given an error message is to look at the 
message that pops up, and due to this design, that error message cannot contain any information that is specific to the 
source of the problem; it actually cannot even assume there is a problem.

I would very much like to know why an existing attribute was shoehorned into working as an error message 
*(but-not-really)*.

As a side note, I'd like to also mention that showing specific information about validation failures elsewhere on the 
page fundamentally necessitates using JavaScript to catch specific error events and update some piece of DOM with the 
relevant guidance. 


[MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/pattern#Accessibility_Concerns)