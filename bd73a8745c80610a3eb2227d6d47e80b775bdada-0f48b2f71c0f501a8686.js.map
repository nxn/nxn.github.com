{"version":3,"sources":["webpack:///./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js","webpack:///./src/components/controls/textfield.tsx"],"names":["_taggedTemplateLiteralLoose","strings","raw","slice","defaultErrors","valueMissing","template","tooLong","tooShort","rangeOverflow","rangeUnderflow","badInput","typeMismatch","stepMismatch","patternMismatch","TextField","props","multiline","deferValidation","errors","onInvalid","other","Component","TextAreaField","TextInputField","errorMessages","fieldRef","React","useRef","useEffect","current","field","element","error","type","toLowerCase","required","validity","value","trim","pattern","maxLength","minLength","max","min","step","setCustomValidity","reportValidity","classList","remove","Object","values","ref","event","add","theme","styles","controls","textbox"],"mappings":"iLAAe,SAASA,EAA4BC,EAASC,GAM3D,OALKA,IACHA,EAAMD,EAAQE,MAAM,IAGtBF,EAAQC,IAAMA,EACPD,E,69CCqBT,IAAMG,EAAgB,CAClBC,aAAoBC,YAAR,KACZC,QAAoBD,YAAb,IAAiE,aACxEE,SAAoBF,YAAZ,IAAiE,aACzEG,cAAoBH,YAAP,IAA0D,OACvEI,eAAoBJ,YAAN,IAAyD,OACvEK,SAAoBL,YAAZ,IAA4D,QACpEM,aAAoBN,YAAR,IAA8C,QAC1DO,aAAoBP,YAAR,IAAwD,QACpEQ,gBAAoBR,YAAL,IAAiB,UAU7B,SAASS,EAAUC,GAAoC,IAClDC,EAA4DD,EAA5DC,UAAWC,EAAiDF,EAAjDE,gBAAiBC,EAAgCH,EAAhCG,OAAQC,EAAwBJ,EAAxBI,UAAcC,EADA,YACUL,EADV,sDAEpDM,EAAYL,EAAYM,EAAgBC,EACxCC,EAAgB,EAAH,KACZrB,GACAe,GAGDO,EAAWC,IAAMC,OAAwD,MAoB/ED,IAAME,WAbiB,WACnB,GAAKH,EAASI,QAAd,CACA,IAAMC,EAAQL,EAASI,SA6C/B,SAA2BE,EAA2Bb,GAClD,IAAIc,EAAQ,GACNC,GAAQF,EAAQE,MAAQ,IAAIC,cAG9BH,EAAQI,WAAaJ,EAAQK,SAAShC,cAAyC,KAAzB2B,EAAQM,MAAMC,QACpEN,EAAQd,EAAOd,aAAa2B,GAEvBA,EAAQQ,SAAWR,EAAQK,SAASvB,gBACzCmB,EAAQd,EAAOL,gBAAgBkB,GAE1BA,EAAQS,WAAaT,EAAQK,SAAS9B,QAC3C0B,EAAQd,EAAOZ,QAAQyB,GAElBA,EAAQU,WAAaV,EAAQK,SAAS7B,SAC3CyB,EAAQd,EAAOX,SAASwB,GAEnBA,EAAQW,KAAOX,EAAQK,SAAS5B,cACrCwB,EAAQd,EAAOV,cAAcuB,GAExBA,EAAQY,KAAOZ,EAAQK,SAAS3B,eACrCuB,EAAQd,EAAOT,eAAesB,GAEzBA,EAAQa,MAAQb,EAAQK,SAASxB,aACtCoB,EAAQd,EAAON,aAAamB,GAEb,UAATE,GAA6B,QAATA,IAAmBF,EAAQK,SAASzB,aAGzDoB,EAAQK,SAAS1B,WACtBsB,EAAQd,EAAOR,SAASqB,IAHxBC,EAAQd,EAAOP,aAAaoB,GAMhCA,EAAQc,kBAAkBb,GA7EtBa,CAAkBf,EAAON,IACpBP,GAAmBa,EAAMgB,kBAC1BhB,EAAMiB,UAAUC,OAAO,cAQ/B,CACIvB,EAASI,QACTJ,EAASI,SAAWJ,EAASI,QAAQQ,MACrCpB,GAHJ,mBAIOgC,OAAOC,OAAO1B,MAerB,OACI,YAACH,EAAD,aACI8B,IAAgB1B,EAChBN,UAbc,SAACiC,GACfjC,GACAA,EAAUiC,GAGV3B,EAASI,SACTJ,EAASI,QAAQkB,UAAUM,IAAI,aAQ1BjC,IA+CjB,IAAMG,EAAoB,kEAAa,qBAAE+B,MAAiBC,OAAOC,SAASC,UAAhD,IACpBnC,EAAoB,oEAAgB,qBAAEgC,MAAiBC,OAAOC,SAASC,UAAnD","file":"bd73a8745c80610a3eb2227d6d47e80b775bdada-0f48b2f71c0f501a8686.js","sourcesContent":["export default function _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  strings.raw = raw;\n  return strings;\n}","import React  from \"react\";\nimport styled from \"@emotion/styled\";\n\nimport { template } from '../../util';\n\ntype HTMLInputProps     = React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;\ntype HTMLTextAreaProps  = React.DetailedHTMLProps<React.TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement>;\n\n// TODO: Unfortunately, if the `multiline` prop is optional and omitted the type system accepts props from both. It\n// only works as intended if a false value is provided explicitly.\nexport type TextInputFieldProps = { multiline?: false } & HTMLInputProps;\nexport type TextAreaFieldProps  = { multiline: true }   & HTMLTextAreaProps;\n\ntype TextFieldElement = HTMLInputElement & HTMLTextAreaElement;\n\n/* Exhaustive list of validity states that should indicate an invalid field state:\n    badInput\n    patternMismatch\n    rangeOverflow\n    rangeUnderflow\n    stepMismatch\n    tooLong\n    tooShort\n    typeMismatch\n    valueMissing\n*/\n\nconst defaultErrors = {\n    valueMissing:       template`This field cannot be blank or empty`,\n    tooLong:            template`This value is too long, maximum length: ${ 'maxLength' }`,\n    tooShort:           template`This value is too short, minimum length: ${ 'minLength' }`,\n    rangeOverflow:      template`This value is too large, maximum size: ${ 'max' }`,\n    rangeUnderflow:     template`This value is too small, minimum size: ${ 'min' }`,\n    badInput:           template`This value cannot be converted to a ${ 'type' }`,\n    typeMismatch:       template`This value is not a valid ${ 'type' } address`,\n    stepMismatch:       template`This value must be in increments of ${ 'step' }`,\n    patternMismatch:    template`${ 'title' }`,\n}\n\ntype Errors = typeof defaultErrors;\n\nexport type TextFieldProps = (TextInputFieldProps | TextAreaFieldProps) & {\n    errors?: { [ P in keyof Errors ]?: Errors[P] },\n    deferValidation?: boolean\n};\n\nexport function TextField(props: TextFieldProps): JSX.Element {\n    const { multiline, deferValidation, errors, onInvalid, ...other } = props;\n    const Component = multiline ? TextAreaField : TextInputField;\n    const errorMessages = {\n        ...defaultErrors,\n        ...errors\n    };\n\n    const fieldRef = React.useRef<(HTMLInputElement & HTMLTextAreaElement) | null>(null);\n\n    // TODO: The custom validity message displayed by the browser sometimes shows a residual message associated with the\n    // prior state rather than the current value of the field. This happens despite `reportValidity()` being called\n    // after having set the new message. This is most noticeable when a field becomes valid -- the `.invalid` class is\n    // removed as expected, but the browser's (firefox in this case) error pop up remains visible on screen for some\n    // reason. This issue might be unavoidable/out of my control.\n    const updateValidity = () => {\n        if (!fieldRef.current) { return; }\n        const field = fieldRef.current;\n        setCustomValidity(field, errorMessages);\n        if (!deferValidation && field.reportValidity()) {\n            field.classList.remove('invalid');\n        }\n    }\n\n    // Needs to execute on each value change to make sure that validity is up to date. Also depends on `deferValidation`\n    // and `errorMessages` values. The reason this isn't done via `onInput` or `onChange` events is that these events \n    // only fire as a result of user initiated interactions. However, validity must also be updated whenever the value\n    // is changed via other sources, for example redux state changes, form resets, etc.\n    React.useEffect(updateValidity, [\n        fieldRef.current,\n        fieldRef.current && fieldRef.current.value,\n        deferValidation,\n        ...Object.values(errorMessages)\n    ]);\n\n    // Event will fire when a form submition is attempted or if the field's `checkValidity()` or `reportValidity()` \n    // methods are used while the current value is invalid.\n    const handleInvalid = (event: React.FormEvent<TextFieldElement>) => {\n        if (onInvalid) {\n            onInvalid(event);\n        }\n\n        if (fieldRef.current) {\n            fieldRef.current.classList.add('invalid');\n        }\n    };\n\n    return (\n        <Component \n            ref         = { fieldRef } \n            onInvalid   = { handleInvalid }\n            { ...other as HTMLInputProps & HTMLTextAreaProps } />\n    );\n}\n\n// Function determines which error message, if any, should be shown once a form submition is attempted. It is\n// important to note that this function should not cause any error messages or error styles to be shown prior to\n// that point. In order to achieve this, `element.checkValidity()` should NOT be used as it can trigger an `invalid`\n// event to be fired and this would subsequently modify the field's style to reflect an error.\n\n// Furthermore, the `element.checkValidity()` function also considers empty strings to be valid inputs for \n// `required` fields, which is unwanted behavior.\nfunction setCustomValidity(element: TextFieldElement, errors: Errors) {\n    let error = \"\";\n    const type = (element.type || '').toLowerCase();\n\n    // Treat empty and blank strings as missing\n    if (element.required && (element.validity.valueMissing || element.value.trim() === '')) {\n        error = errors.valueMissing(element);\n    }\n    else if (element.pattern && element.validity.patternMismatch) {\n        error = errors.patternMismatch(element);\n    }\n    else if (element.maxLength && element.validity.tooLong) {\n        error = errors.tooLong(element);\n    }\n    else if (element.minLength && element.validity.tooShort) {\n        error = errors.tooShort(element);\n    }\n    else if (element.max && element.validity.rangeOverflow) {\n        error = errors.rangeOverflow(element);\n    }\n    else if (element.min && element.validity.rangeUnderflow) {\n        error = errors.rangeUnderflow(element);\n    }\n    else if (element.step && element.validity.stepMismatch) {\n        error = errors.stepMismatch(element);\n    }\n    else if ((type === 'email' || type === 'url') && element.validity.typeMismatch) {\n        error = errors.typeMismatch(element);\n    }\n    else if (element.validity.badInput) {\n        error = errors.badInput(element);\n    }\n\n    element.setCustomValidity(error);\n};\n\nconst TextInputField    = styled.input(({theme}) => theme.styles.controls.textbox);\nconst TextAreaField     = styled.textarea(({theme}) => theme.styles.controls.textbox);\n\nexport default TextField;"],"sourceRoot":""}